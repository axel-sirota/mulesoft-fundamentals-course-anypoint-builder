<?xml version="1.0" encoding="UTF-8"?>
<!-- Solution: Module 1 â€” Customer Sync Demo (The MuleSoft Way)
     Pre-built Mule flow that does exactly what demo-coupled.py does,
     but with proper error handling, config-driven URLs, and DataWeave transforms. -->
<mule xmlns:ee="http://www.mulesoft.org/schema/mule/ee/core"
      xmlns:http="http://www.mulesoft.org/schema/mule/http"
      xmlns="http://www.mulesoft.org/schema/mule/core"
      xmlns:doc="http://www.mulesoft.org/schema/mule/documentation"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="
        http://www.mulesoft.org/schema/mule/core http://www.mulesoft.org/schema/mule/core/current/mule.xsd
        http://www.mulesoft.org/schema/mule/http http://www.mulesoft.org/schema/mule/http/current/mule-http.xsd
        http://www.mulesoft.org/schema/mule/ee/core http://www.mulesoft.org/schema/mule/ee/core/current/mule-ee.xsd">

    <!-- ============================================ -->
    <!-- Global Configurations                        -->
    <!-- URLs come from application.properties,       -->
    <!-- NOT hardcoded like demo-coupled.py            -->
    <!-- ============================================ -->

    <!-- HTTP Listener: Exposes our sync endpoint -->
    <http:listener-config name="HTTP_Listener_Config" doc:name="HTTP Listener Config">
        <http:listener-connection host="0.0.0.0" port="${http.port}" />
    </http:listener-config>

    <!-- HTTP Request: Source API (Mock Customer API) -->
    <http:request-config name="Source_API_Config" doc:name="Source API Config">
        <http:request-connection host="${source.api.host}" port="${source.api.port}" />
    </http:request-config>

    <!-- HTTP Request: Target API (Mock Import endpoint) -->
    <http:request-config name="Target_API_Config" doc:name="Target API Config">
        <http:request-connection host="${target.api.host}" port="${target.api.port}" />
    </http:request-config>

    <!-- ============================================ -->
    <!-- Main Flow: Customer Sync                     -->
    <!-- GET /api/customers/sync                      -->
    <!-- ============================================ -->
    <flow name="customer-sync-flow" doc:name="Customer Sync Flow">
        <http:listener config-ref="HTTP_Listener_Config"
                       path="/api/customers/sync"
                       doc:name="GET /api/customers/sync"
                       allowedMethods="GET" />

        <try doc:name="Try Scope">
            <!-- Step 1: Fetch all customers from source API -->
            <http:request config-ref="Source_API_Config"
                          method="GET"
                          path="${source.api.basePath}/customers"
                          doc:name="GET /api/customers" />

            <!-- Step 2: Filter Technology customers + rename fields -->
            <ee:transform doc:name="Filter &amp; Transform">
                <ee:message>
                    <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
payload filter ($.industry == "Technology") map (customer) -> {
    full_name: customer.firstName ++ " " ++ customer.lastName,
    contact_email: customer.email,
    organization: customer.company,
    location: customer.billingCity ++ ", " ++ customer.billingState,
    source: "sf-org-a"
}]]></ee:set-payload>
                </ee:message>
            </ee:transform>

            <!-- Step 3: POST transformed customers to target -->
            <http:request config-ref="Target_API_Config"
                          method="POST"
                          path="${target.api.basePath}/customers/import"
                          doc:name="POST /api/customers/import">
                <http:body><![CDATA[#[payload]]]></http:body>
                <http:headers><![CDATA[#[{"Content-Type": "application/json"}]]]></http:headers>
            </http:request>

            <!-- Step 4: Log success -->
            <logger level="INFO"
                    message='#["Sync complete: " ++ sizeOf(payload) ++ " customers imported"]'
                    doc:name="Log Result" />

            <!-- Error Handling: structured responses, not crashes -->
            <error-handler>
                <!-- Connectivity errors: source or target API is down -->
                <on-error-continue type="HTTP:CONNECTIVITY, MULE:CONNECTIVITY"
                                   enableNotifications="false"
                                   logException="false">
                    <ee:transform doc:name="503 Error Response">
                        <ee:message>
                            <ee:set-payload><![CDATA[%dw 2.0
output application/json
---
{
    error: "Source API unavailable",
    detail: error.description,
    timestamp: now() as String {format: "yyyy-MM-dd'T'HH:mm:ss'Z'"}
}]]></ee:set-payload>
                        </ee:message>
                        <ee:variables>
                            <ee:set-variable variableName="httpStatus"><![CDATA[503]]></ee:set-variable>
                        </ee:variables>
                    </ee:transform>
                    <set-variable variableName="httpStatus" value="503" doc:name="Set HTTP 503" />
                </on-error-continue>

                <!-- All other errors: log and propagate -->
                <on-error-propagate type="ANY">
                    <logger level="ERROR"
                            message='#["Unexpected error in customer-sync: " ++ error.description]'
                            doc:name="Log Unexpected Error" />
                </on-error-propagate>
            </error-handler>
        </try>
    </flow>
</mule>
