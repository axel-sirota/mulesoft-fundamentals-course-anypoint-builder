<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Module 3: Designing the Customer 360 API â€” MuleSoft Basics</title>

  <!-- Mermaid.js for diagrams -->
  <script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
    mermaid.initialize({
      startOnLoad: true,
      theme: 'dark',
      themeVariables: {
        primaryColor: '#00A1E0',
        primaryTextColor: '#FFFFFF',
        primaryBorderColor: '#0078D4',
        lineColor: '#8B949E',
        secondaryColor: '#1A1F36',
        tertiaryColor: '#2D333B'
      }
    });
  </script>

  <!-- Prism.js for syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.css"/>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>

  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

  <style>
    :root {
      --sidebar-bg: #1A1F36;
      --accent-primary: #00A1E0;
      --accent-secondary: #0078D4;
      --bg-main: #F8F9FA;
      --bg-section: #FFFFFF;
      --bg-lab: #F0F7FF;
      --bg-lab-advanced: #F5F0FF;
      --text-primary: #1A1F36;
      --text-secondary: #6B7280;
      --border-light: #E5E7EB;
      --callout-info: #DBEAFE;
      --callout-success: #D1FAE5;
      --callout-warning: #FEF3C7;
      --callout-danger: #FEE2E2;
      --callout-instructor: #EDE9FE;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      font-size: 18px;
      line-height: 1.6;
      color: var(--text-primary);
      background: var(--bg-main);
      display: flex;
    }

    /* Sidebar */
    .sidebar {
      width: 280px;
      min-height: 100vh;
      background: var(--sidebar-bg);
      color: #fff;
      padding: 2rem 1.5rem;
      position: fixed;
      left: 0;
      top: 0;
      overflow-y: auto;
      z-index: 100;
    }
    .sidebar h2 { font-size: 1rem; font-weight: 600; margin-bottom: 1.5rem; color: var(--accent-primary); }
    .sidebar a { display: block; color: #C9CDD5; text-decoration: none; padding: 0.5rem 0; font-size: 0.9rem; transition: color 0.2s; }
    .sidebar a:hover, .sidebar a.active { color: var(--accent-primary); }
    .sidebar .section-group { margin-bottom: 1rem; }
    .sidebar .section-group-title { font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.05em; color: #8B949E; margin-bottom: 0.25rem; }

    /* Main Content */
    .content {
      margin-left: 280px;
      max-width: 900px;
      padding: 2rem 3rem 4rem;
      width: calc(100% - 280px);
    }

    /* Header */
    .module-header { margin-bottom: 3rem; }
    .badges { display: flex; gap: 0.75rem; margin-bottom: 1rem; }
    .badge {
      display: inline-block;
      padding: 0.25rem 0.75rem;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 600;
    }
    .badge-duration { background: var(--accent-primary); color: #fff; }
    .badge-day { background: var(--sidebar-bg); color: #fff; }
    .module-header h1 { font-size: 2.2rem; font-weight: 700; line-height: 1.2; margin-bottom: 0.5rem; }
    .subtitle { font-size: 1.1rem; color: var(--text-secondary); margin-bottom: 1.5rem; }

    .objectives {
      background: var(--callout-info);
      border-left: 4px solid var(--accent-primary);
      padding: 1.25rem 1.5rem;
      border-radius: 0 8px 8px 0;
    }
    .objectives h3 { font-size: 1rem; margin-bottom: 0.5rem; color: var(--accent-secondary); }
    .objectives ul { padding-left: 1.25rem; }
    .objectives li { margin-bottom: 0.25rem; font-size: 0.95rem; }

    /* Sections */
    section { margin-bottom: 3rem; }
    section h2 {
      font-size: 1.5rem;
      font-weight: 700;
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 2px solid var(--accent-primary);
    }
    section h3 { font-size: 1.2rem; font-weight: 600; margin: 1.5rem 0 0.75rem; }
    section h4 { font-size: 1rem; font-weight: 600; margin: 1rem 0 0.5rem; }
    p { margin-bottom: 1rem; }

    /* Callout boxes */
    .callout {
      padding: 1.25rem 1.5rem;
      border-radius: 8px;
      margin: 1.5rem 0;
      border-left: 4px solid;
    }
    .callout-title { font-weight: 600; margin-bottom: 0.5rem; }
    .callout-info { background: var(--callout-info); border-color: var(--accent-primary); }
    .callout-success { background: var(--callout-success); border-color: #059669; }
    .callout-warning { background: var(--callout-warning); border-color: #D97706; }
    .callout-danger { background: var(--callout-danger); border-color: #DC2626; }

    /* Instructor Notes */
    details.instructor-note {
      background: var(--callout-instructor);
      border: 1px solid #C4B5FD;
      border-radius: 8px;
      padding: 1rem 1.25rem;
      margin: 1.5rem 0;
    }
    details.instructor-note summary {
      font-weight: 600;
      cursor: pointer;
      color: #6D28D9;
    }
    details.instructor-note ol, details.instructor-note ul { padding-left: 1.25rem; margin-top: 0.75rem; }
    details.instructor-note li { margin-bottom: 0.5rem; }

    /* Code blocks */
    pre[class*="language-"] {
      border-radius: 8px;
      font-size: 15px;
      line-height: 1.4;
      margin: 1rem 0;
    }
    code { font-family: 'JetBrains Mono', monospace; }
    :not(pre) > code {
      background: #F3F4F6;
      padding: 0.15rem 0.4rem;
      border-radius: 4px;
      font-size: 0.9em;
      color: #DC2626;
    }

    /* Diagram container */
    .diagram-container { margin: 1.5rem 0; text-align: center; }
    .diagram-caption { font-size: 0.85rem; color: var(--text-secondary); margin-top: 0.5rem; font-style: italic; }
    .mermaid { background: var(--sidebar-bg); padding: 1.5rem; border-radius: 8px; }

    /* Code compare side-by-side */
    .code-compare { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin: 1.5rem 0; }
    .code-panel h4 { font-size: 0.9rem; margin-bottom: 0.25rem; }

    /* Comparison table */
    table { width: 100%; border-collapse: collapse; margin: 1.5rem 0; font-size: 0.95rem; }
    th, td { padding: 0.75rem 1rem; text-align: left; border-bottom: 1px solid var(--border-light); }
    th { background: var(--sidebar-bg); color: #fff; font-weight: 600; }
    tr:nth-child(even) { background: #F9FAFB; }

    /* Lab section */
    .lab-section {
      background: var(--bg-lab);
      border: 2px solid #93C5FD;
      border-radius: 12px;
      padding: 2rem;
      margin: 2rem 0;
    }
    .lab-section h2 { border-bottom-color: var(--accent-secondary); }
    .lab-step { display: flex; gap: 1rem; margin: 1.5rem 0; align-items: flex-start; }
    .step-number {
      background: var(--accent-primary);
      color: #fff;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 1rem;
      flex-shrink: 0;
    }
    .step-content { flex: 1; }
    .step-content h4 { margin-bottom: 0.25rem; }
    .validation {
      background: var(--callout-success);
      border-left: 4px solid #059669;
      padding: 0.75rem 1rem;
      border-radius: 0 6px 6px 0;
      margin-top: 0.75rem;
      font-size: 0.9rem;
    }

    /* Advanced/Bonus lab section */
    .lab-section-advanced {
      background: var(--bg-lab-advanced);
      border: 2px solid #C4B5FD;
      border-radius: 12px;
      padding: 2rem;
      margin: 2rem 0;
    }
    .lab-section-advanced h2 { border-bottom-color: #7C3AED; }
    .lab-section-advanced .step-number { background: #7C3AED; }

    /* Closing banner */
    .closing-banner {
      background: linear-gradient(135deg, var(--sidebar-bg) 0%, var(--accent-secondary) 100%);
      color: #fff;
      padding: 2rem;
      border-radius: 12px;
      text-align: center;
      margin: 2rem 0;
    }
    .closing-banner h3 { font-size: 1.3rem; margin-bottom: 0.5rem; }
    .closing-banner p { opacity: 0.9; }

    /* Footer */
    .module-footer {
      display: flex;
      justify-content: space-between;
      padding: 2rem 0;
      border-top: 2px solid var(--border-light);
      margin-top: 3rem;
    }
    .module-footer a {
      color: var(--accent-primary);
      text-decoration: none;
      font-weight: 600;
      font-size: 0.95rem;
    }
    .module-footer a:hover { text-decoration: underline; }

    /* Responsive */
    @media (max-width: 1024px) {
      .sidebar { display: none; }
      .content { margin-left: 0; padding: 1.5rem; width: 100%; }
      .code-compare { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>

  <!-- Sidebar Navigation -->
  <nav class="sidebar">
    <h2>MuleSoft Basics</h2>
    <div class="section-group">
      <div class="section-group-title">Module 3</div>
      <a href="#api-led" class="active">API-Led in Practice</a>
      <a href="#raml-concepts">RAML Concepts</a>
      <a href="#policies">Policies &amp; Governance</a>
      <a href="#demo">Demo: Design in ACB</a>
      <a href="#lab1">Lab 1: Build Your API</a>
      <a href="#lab2">Lab 2: Modularize (Bonus)</a>
    </div>
    <div class="section-group">
      <div class="section-group-title">Course</div>
      <a href="../01-intro-to-mulesoft/module-01.html">Module 1: Why MuleSoft?</a>
      <a href="../02-anypoint-platform-tour/module-02.html">Module 2: Platform Tour</a>
      <a href="../04-integrations-rest-soap-db/module-04.html">Module 4: Integrations</a>
      <a href="../05-dataweave/module-05.html">Module 5: DataWeave</a>
      <a href="../06-salesforce-etl-batch/module-06.html">Module 6: SF ETL</a>
      <a href="../07-deploy-manage-llm/module-07.html">Module 7: Deploy &amp; AI</a>
    </div>
  </nav>

  <main class="content">

    <!-- Header -->
    <header class="module-header">
      <div class="badges">
        <span class="badge badge-duration">~3 hours</span>
        <span class="badge badge-day">Day 1</span>
      </div>
      <h1>Designing the Customer 360 API</h1>
      <p class="subtitle">API-first development &mdash; design the contract before writing code</p>
      <div class="objectives">
        <h3>Learning Objectives</h3>
        <ul>
          <li>Create a RAML 1.0 API specification with resources, methods, data types, and examples</li>
          <li>Compare RAML 1.0 and OpenAPI 3.0 approaches</li>
          <li>Use Anypoint Code Builder's API Console and auto-complete to design APIs</li>
          <li>Test APIs with the built-in mocking service</li>
          <li>Publish an API specification to Anypoint Exchange</li>
          <li>Understand API governance and policy concepts</li>
        </ul>
      </div>
    </header>

    <!-- SECTION 1: API-Led Connectivity in Practice -->
    <section id="api-led">
      <h2>Section 1: API-Led Connectivity in Practice</h2>

      <p>In Module 1, you saw the three-layer architecture: Experience, Process, and System APIs. Now you're going to build one. The Customer System API sits at the bottom layer &mdash; a thin, standardized wrapper around Salesforce. Any Process API can call it without knowing SOQL, authentication details, or Salesforce-specific quirks.</p>

      <h3>What We're Building: The Customer System API</h3>

      <p>The diagram below shows where the Customer System API fits. You'll define the contract for five endpoints that expose customer and contact data from the source Salesforce org. In Module 4, you'll implement these endpoints with real connectors.</p>

      <div class="diagram-container">
        <pre class="mermaid">
graph TD
    subgraph Experience["Experience Layer (Module 7)"]
        EXP[Mobile / Web App]
    end
    subgraph Process["Process Layer (Module 4)"]
        PROC[Customer Enrichment<br/>Process API]
    end
    subgraph System["System Layer (This Module)"]
        style SYS fill:#00A1E0,stroke:#0078D4,color:#fff,stroke-width:3px
        SYS[Customer System API]
    end
    subgraph Backends["Backend Systems"]
        SF[Salesforce Source Org]
    end

    EXP -->|"REST calls"| PROC
    PROC -->|"GET /customers"| SYS
    PROC -->|"GET /customers/id"| SYS
    PROC -->|"GET /customers/id/contacts"| SYS
    SYS -->|"SOQL queries"| SF

    classDef expStyle fill:#059669,stroke:#047857,color:#fff
    classDef procStyle fill:#0078D4,stroke:#005A9E,color:#fff
    classDef sysStyle fill:#00A1E0,stroke:#0078D4,color:#fff
    classDef backStyle fill:#6B7280,stroke:#4B5563,color:#fff

    class EXP expStyle
    class PROC procStyle
    class SYS sysStyle
    class SF backStyle
        </pre>
        <p class="diagram-caption">Figure 1: The Customer System API sits at the System layer, wrapping Salesforce with a clean REST interface</p>
      </div>

      <p>The five endpoints you'll define are:</p>
      <table>
        <thead>
          <tr><th>Method</th><th>Path</th><th>Purpose</th></tr>
        </thead>
        <tbody>
          <tr><td><code>GET</code></td><td><code>/customers</code></td><td>List customers from source SF org</td></tr>
          <tr><td><code>POST</code></td><td><code>/customers</code></td><td>Create customer in target SF org</td></tr>
          <tr><td><code>GET</code></td><td><code>/customers/{customerId}</code></td><td>Get single customer</td></tr>
          <tr><td><code>PUT</code></td><td><code>/customers/{customerId}</code></td><td>Update customer</td></tr>
          <tr><td><code>GET</code></td><td><code>/customers/{customerId}/contacts</code></td><td>Get contacts for an account</td></tr>
        </tbody>
      </table>

      <h3 id="raml-concepts">RAML vs OpenAPI: Two Ways to Define an API</h3>

      <p>MuleSoft supports both RAML 1.0 and OpenAPI 3.0 for API specifications. Both describe the same thing &mdash; endpoints, data types, examples &mdash; but with different syntax. We'll use RAML in this course because it has tighter integration with Design Center and is more common in the MuleSoft ecosystem. OpenAPI works fine too; the concepts transfer directly.</p>

      <div class="code-compare">
        <div class="code-panel">
          <h4>RAML 1.0</h4>
          <pre class="language-yaml"><code class="language-yaml">#%RAML 1.0
title: Customer System API
version: v1
baseUri: http://localhost:8081/api

types:
  Customer:
    properties:
      id: string
      firstName: string
      lastName: string
      email: string

/customers:
  get:
    queryParameters:
      industry:
        type: string
        required: false
    responses:
      200:
        body:
          application/json:
            type: Customer[]
            example:
              -
                id: "ACCT-001"
                firstName: "Leanne"
                lastName: "Graham"
                email: "leanne@example.com"</code></pre>
        </div>
        <div class="code-panel">
          <h4>OpenAPI 3.0</h4>
          <pre class="language-yaml"><code class="language-yaml">openapi: 3.0.0
info:
  title: Customer System API
  version: v1
paths:
  /customers:
    get:
      parameters:
        - name: industry
          in: query
          required: false
          schema:
            type: string
      responses:
        '200':
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/Customer'
components:
  schemas:
    Customer:
      type: object
      properties:
        id: { type: string }
        firstName: { type: string }
        lastName: { type: string }
        email: { type: string }</code></pre>
        </div>
      </div>

      <details class="instructor-note">
        <summary>Instructor Note: RAML vs OAS</summary>
        <p>Students may ask "Why not OpenAPI?" Fair question. Answer: MuleSoft supports both. We use RAML because (1) the ACB auto-complete is richer for RAML, (2) Design Center's visual editor works best with RAML, and (3) it's the dominant format in MuleSoft's ecosystem. If they already know OAS, the concepts are identical &mdash; just different syntax.</p>
      </details>

      <h3>Building RAML Concept by Concept</h3>

      <p>RAML specifications are built from a few core concepts that layer on top of each other. Let's walk through them one at a time, building up to a complete spec.</p>

      <h4>Snippet 1: Resources and Methods</h4>
      <p>Resources are the nouns in your API. Methods are the verbs. Nested resources use indentation:</p>

      <pre class="language-yaml"><code class="language-yaml">#%RAML 1.0
title: Customer System API
version: v1
baseUri: http://localhost:8081/api

/customers:
  get:
  post:
  /{customerId}:
    get:
    put:
    /contacts:
      get:</code></pre>

      <p>Just this skeleton already tells consumers the shape of your API. Five endpoints, three resources, a nested hierarchy where contacts belong to a customer.</p>

      <h4>Snippet 2: Data Types</h4>
      <p>Data types define the shape of your request and response payloads. Optional fields use the <code>?</code> suffix:</p>

      <pre class="language-yaml"><code class="language-yaml">types:
  Customer:
    properties:
      id: string
      firstName: string
      lastName: string
      email: string
      phone?: string
      company: string
      industry: string
      billingStreet?: string
      billingCity?: string
      billingState?: string
      billingPostalCode?: string

  Contact:
    properties:
      id: string
      firstName: string
      lastName: string
      email: string
      phone?: string
      title?: string
      accountId: string</code></pre>

      <p>The Customer type has 11 properties (4 optional), and Contact has 7 (2 optional). These types are referenced by your endpoints to validate payloads automatically.</p>

      <h4>Snippet 3: Query Parameters</h4>
      <p>Query parameters let consumers filter and paginate results. You can set types, defaults, and constraints:</p>

      <pre class="language-yaml"><code class="language-yaml">/customers:
  get:
    queryParameters:
      industry:
        type: string
        required: false
        description: Filter by industry
      limit:
        type: integer
        default: 25
        minimum: 1
        maximum: 100
      offset:
        type: integer
        default: 0</code></pre>

      <p>The <code>minimum</code> and <code>maximum</code> facets constrain integer values. The mocking service uses <code>default</code> values when testing.</p>

      <h4>Snippet 4: Examples</h4>
      <p>Examples serve double duty &mdash; they're documentation for consumers, and they're the responses the mocking service returns when you test. Always use realistic data:</p>

      <pre class="language-yaml"><code class="language-yaml">/customers:
  get:
    responses:
      200:
        body:
          application/json:
            type: Customer[]
            example:
              -
                id: "ACCT-001"
                firstName: "Leanne"
                lastName: "Graham"
                email: "leanne.graham@romaguera.com"
                company: "Romaguera-Crona"
                industry: "Technology"
              -
                id: "ACCT-002"
                firstName: "Ervin"
                lastName: "Howell"
                email: "ervin.howell@deckow.com"
                company: "Deckow-Crist"
                industry: "Technology"</code></pre>

      <div class="callout callout-info">
        <div class="callout-title">Key Concept: Examples Power the Mocking Service</div>
        <p>The examples you define in your spec are exactly what the mocking service returns. When you click "Try It" in the API Console, it sends back your example data. This means your API works before you've written a single line of implementation.</p>
      </div>

      <h4>Snippet 5: Traits (Reusable Patterns)</h4>
      <p>Traits let you define cross-cutting concerns once and apply them everywhere. Error responses are the classic use case &mdash; every endpoint needs 400, 404, and 500 responses:</p>

      <pre class="language-yaml"><code class="language-yaml">traits:
  errorResponses:
    responses:
      400:
        body:
          application/json:
            example:
              message: "Bad request"
              code: 400
      404:
        body:
          application/json:
            example:
              message: "Resource not found"
              code: 404
      500:
        body:
          application/json:
            example:
              message: "Internal server error"
              code: 500

/customers:
  get:
    is: [errorResponses]
  post:
    is: [errorResponses]
  /{customerId}:
    get:
      is: [errorResponses]</code></pre>

      <p>The <code>is: [errorResponses]</code> line applies the trait to that method. Every method that uses it automatically gets 400, 404, and 500 response definitions. Write once, apply everywhere.</p>

    </section>

    <!-- SECTION 2: API Policies & Governance -->
    <section id="policies">
      <h2>Section 2: API Policies &amp; Governance</h2>

      <p>Designing your API contract is just the beginning. Once your API is deployed, you need to protect it. API policies sit between consumers and your implementation, enforcing rules before requests ever reach your code.</p>

      <div class="diagram-container">
        <pre class="mermaid">
graph LR
    Client[API Consumer] --> GW[API Gateway]
    subgraph Policies["Applied Policies"]
        RL[Rate Limiting<br/>10 req/min]
        CID[Client ID<br/>Enforcement]
        IP[IP<br/>Allowlist]
    end
    GW --> RL
    RL --> CID
    CID --> IP
    IP --> API[Your API<br/>Implementation]
    API --> Backend[Salesforce]

    classDef gwStyle fill:#D97706,stroke:#B45309,color:#fff
    classDef polStyle fill:#7C3AED,stroke:#5B21B6,color:#fff
    classDef apiStyle fill:#00A1E0,stroke:#0078D4,color:#fff

    class GW gwStyle
    class RL,CID,IP polStyle
    class API apiStyle
        </pre>
        <p class="diagram-caption">Figure 2: The API Gateway enforces policies before requests reach your implementation</p>
      </div>

      <p>Rate limiting protects your API from being overwhelmed &mdash; you set a maximum number of requests per time window, and the gateway enforces it. Client ID enforcement ensures only registered applications can call your API; consumers must include a valid client ID and secret with each request. OAuth 2.0 adds user-level authentication on top of application-level access. IP allowlisting restricts access to known networks, useful for internal System APIs. Spike control smooths traffic bursts by queuing excess requests instead of rejecting them.</p>

      <p>The workflow is: you publish your spec to Exchange, create an API instance in API Manager, and attach policies. The gateway enforces them at runtime. Your implementation code never needs to know about rate limits or authentication &mdash; the gateway handles it.</p>

      <div class="callout callout-warning">
        <div class="callout-title">Coming in Module 7</div>
        <p>We won't configure policies in this lab. You'll deploy your API and apply Rate Limiting in Module 7 when we cover CloudHub deployment and API Manager.</p>
      </div>

    </section>

    <!-- SECTION 3: DEMO -->
    <section id="demo">
      <h2>Section 3: Demo &mdash; Designing in Anypoint Code Builder</h2>

      <p>Watch the instructor create a RAML spec from scratch in ACB, test it with the mocking service, and publish it to Exchange &mdash; all without leaving VS Code.</p>

      <details class="instructor-note">
        <summary>Instructor Demo: Design a RAML Spec in ACB (~15 min)</summary>
        <ol>
          <li>Open ACB (VS Code with the Anypoint Extension Pack). Click the <strong>Anypoint Code Builder</strong> icon in the activity bar (left sidebar).</li>
          <li>Under Quick Actions, click <strong>"Design an API"</strong>. Fill in: Project Name = "Customer System API Demo", select RAML 1.0, choose your business group, pick a project location. Click <strong>Create Project</strong>.</li>
          <li>ACB opens a template RAML file. Write the <code>/customers</code> GET endpoint with a <code>Customer</code> data type. Use <strong>Ctrl+Space</strong> to show auto-complete &mdash; demonstrate how ACB suggests RAML keywords (<code>types:</code>, <code>properties:</code>, <code>responses:</code>).</li>
          <li>Add the <code>Customer</code> type with <code>id</code>, <code>firstName</code>, <code>lastName</code>, <code>email</code>. Show the <code>?</code> suffix for optional fields.</li>
          <li>Add an example response payload with ACCT-001 data. Point out: "These examples are real test data. The mocking service will return exactly this."</li>
          <li>Click the <strong>API Console</strong> icon in the top-right of the editor toolbar. The API Console panel opens on the right side.</li>
          <li>In the API Console, select <strong>GET /customers</strong>. Click <strong>Try It</strong>. Click <strong>Send</strong>.</li>
          <li><strong>Key moment:</strong> The mocking service returns your example payload. "Your API works &mdash; and you haven't written a single line of implementation. This is what API-first development looks like." Pause here. Let this sink in.</li>
          <li>Open the Command Palette (<strong>Cmd+Shift+P</strong> on Mac, <strong>Ctrl+Shift+P</strong> on Windows). Type <strong>"MuleSoft: Publish API Project to Exchange"</strong>.</li>
          <li>Click <strong>Allow</strong> to authenticate, select your business group. Fill in: Asset version = <strong>1.0.0</strong>, API version = <strong>v1</strong>. Confirm the publish.</li>
          <li>Open Anypoint Platform in a browser. Navigate to Exchange. Search for "Customer System API Demo" &mdash; it appears as a published asset. Click it to show the summary and endpoints.</li>
          <li>Clean up: delete the demo spec from Exchange to avoid confusion with the students' work.</li>
        </ol>
        <p><strong>Recovery:</strong> If the API Console doesn't open, check that the RAML file has no syntax errors (red underlines). The API Console requires a valid spec. If publish fails, verify you're logged into Anypoint Platform (check the status bar at the bottom of VS Code).</p>
        <p><strong>Talking point:</strong> "Ask the room: how many of you have written API code before having a design? That's building the house before the blueprints. In Module 4, you'll scaffold your Mule project directly from this spec &mdash; the spec becomes the blueprint."</p>
      </details>

    </section>

    <!-- SECTION 4: LAB 1 -->
    <section id="lab1" class="lab-section">
      <h2>Lab 1: Build Your API Contract</h2>

      <p>You'll create a complete RAML 1.0 specification for the Customer System API. This is the contract &mdash; the foundation for everything you build in Modules 4-7. In Module 4, you'll scaffold your Mule project directly from this spec.</p>

      <div class="callout callout-info">
        <div class="callout-title">Starting Point</div>
        <p>Open the starter file at <code>lab/starter/customer-system-api.raml</code> in ACB. It has the RAML header, resource skeleton, and 8 numbered TODOs for you to complete.</p>
      </div>

      <!-- Step 1 -->
      <div class="lab-step">
        <div class="step-number">1</div>
        <div class="step-content">
          <h4>Define the Customer Data Type</h4>
          <p>Add a <code>types:</code> block after the header. Define the <code>Customer</code> type with 11 properties. Use <code>?</code> for optional fields (phone, billingStreet, billingCity, billingState, billingPostalCode).</p>
<pre class="language-yaml"><code class="language-yaml">types:
  Customer:
    properties:
      id: string
      firstName: string
      lastName: string
      email: string
      phone?: string
      company: string
      industry: string
      billingStreet?: string
      billingCity?: string
      billingState?: string
      billingPostalCode?: string</code></pre>
          <div class="validation">Validation: No red error underlines in ACB. The type compiles successfully.</div>
        </div>
      </div>

      <!-- Step 2 -->
      <div class="lab-step">
        <div class="step-number">2</div>
        <div class="step-content">
          <h4>Define the Contact Data Type</h4>
          <p>Add the <code>Contact</code> type under the same <code>types:</code> block. 7 properties, 2 optional (<code>phone</code>, <code>title</code>).</p>
<pre class="language-yaml"><code class="language-yaml">  Contact:
    properties:
      id: string
      firstName: string
      lastName: string
      email: string
      phone?: string
      title?: string
      accountId: string</code></pre>
          <div class="validation">Validation: Both Customer and Contact types compile without errors.</div>
        </div>
      </div>

      <!-- Step 3 -->
      <div class="lab-step">
        <div class="step-number">3</div>
        <div class="step-content">
          <h4>Create GET /customers</h4>
          <p>Under the <code>/customers:</code> resource, add a <code>get:</code> method with query parameters (<code>industry</code>, <code>limit</code>, <code>offset</code>) and a 200 response returning <code>Customer[]</code> with an example of 3 customers.</p>
<pre class="language-yaml"><code class="language-yaml">/customers:
  get:
    is: [errorResponses]
    description: List customers, optionally filtered by industry
    queryParameters:
      industry:
        type: string
        required: false
        description: Filter customers by industry
      limit:
        type: integer
        default: 25
        minimum: 1
        maximum: 100
      offset:
        type: integer
        default: 0
    responses:
      200:
        body:
          application/json:
            type: Customer[]
            example:
              -
                id: "ACCT-001"
                firstName: "Leanne"
                lastName: "Graham"
                email: "leanne.graham@romaguera.com"
                company: "Romaguera-Crona"
                industry: "Technology"
              -
                id: "ACCT-002"
                firstName: "Ervin"
                lastName: "Howell"
                email: "ervin.howell@deckow.com"
                company: "Deckow-Crist"
                industry: "Technology"
              -
                id: "ACCT-004"
                firstName: "Patricia"
                lastName: "Lebsack"
                email: "patricia.lebsack@robel.com"
                company: "Robel-Corkery"
                industry: "Technology"</code></pre>
          <p><strong>Note:</strong> The <code>is: [errorResponses]</code> line won't work until you complete Step 7. You can add it now or come back to it.</p>
          <div class="validation">Validation: Click the API Console icon (top right). Select GET /customers, click Try It, click Send. The mocking service returns your 3 example customers.</div>
        </div>
      </div>

      <!-- Step 4 -->
      <div class="lab-step">
        <div class="step-number">4</div>
        <div class="step-content">
          <h4>Create POST /customers</h4>
          <p>Add a <code>post:</code> method under <code>/customers:</code> with a request body (<code>Customer</code> type) and a 201 response.</p>
<pre class="language-yaml"><code class="language-yaml">  post:
    is: [errorResponses]
    description: Create a new customer
    body:
      application/json:
        type: Customer
        example:
          id: "ACCT-011"
          firstName: "Jane"
          lastName: "Doe"
          email: "jane.doe@newcorp.com"
          company: "NewCorp Industries"
          industry: "Technology"
    responses:
      201:
        body:
          application/json:
            type: Customer
            example:
              id: "ACCT-011"
              firstName: "Jane"
              lastName: "Doe"
              email: "jane.doe@newcorp.com"
              company: "NewCorp Industries"
              industry: "Technology"</code></pre>
          <div class="validation">Validation: In the API Console, Try It on POST /customers with the example body. Returns 201 with the created customer.</div>
        </div>
      </div>

      <!-- Step 5 -->
      <div class="lab-step">
        <div class="step-number">5</div>
        <div class="step-content">
          <h4>Create GET and PUT /customers/{customerId}</h4>
          <p>Under the <code>/{customerId}:</code> resource, add both a <code>get:</code> returning a single Customer (with full billing details in the example) and a <code>put:</code> that accepts a Customer body and returns the updated version.</p>
<pre class="language-yaml"><code class="language-yaml">  /{customerId}:
    get:
      is: [errorResponses]
      description: Get a single customer by ID
      responses:
        200:
          body:
            application/json:
              type: Customer
              example:
                id: "ACCT-001"
                firstName: "Leanne"
                lastName: "Graham"
                email: "leanne.graham@romaguera.com"
                phone: "555-0001"
                company: "Romaguera-Crona"
                industry: "Technology"
                billingStreet: "123 Innovation Drive"
                billingCity: "San Francisco"
                billingState: "CA"
                billingPostalCode: "94105"

    put:
      is: [errorResponses]
      description: Update an existing customer
      body:
        application/json:
          type: Customer
          example:
            id: "ACCT-001"
            firstName: "Leanne"
            lastName: "Graham"
            email: "leanne.graham@romaguera.com"
            phone: "555-0001"
            company: "Romaguera-Crona"
            industry: "Technology"
            billingStreet: "456 Updated Blvd"
            billingCity: "San Francisco"
            billingState: "CA"
            billingPostalCode: "94105"
      responses:
        200:
          body:
            application/json:
              type: Customer
              example:
                id: "ACCT-001"
                firstName: "Leanne"
                lastName: "Graham"
                email: "leanne.graham@romaguera.com"
                phone: "555-0001"
                company: "Romaguera-Crona"
                industry: "Technology"
                billingStreet: "456 Updated Blvd"
                billingCity: "San Francisco"
                billingState: "CA"
                billingPostalCode: "94105"</code></pre>
          <div class="validation">Validation: Both GET and PUT endpoints appear in the API Console with correct methods.</div>
        </div>
      </div>

      <!-- Step 6 -->
      <div class="lab-step">
        <div class="step-number">6</div>
        <div class="step-content">
          <h4>Create GET /customers/{customerId}/contacts</h4>
          <p>Under the <code>/contacts:</code> resource (nested inside <code>/{customerId}:</code>), add a <code>get:</code> returning <code>Contact[]</code> with an example of 2 contacts.</p>
<pre class="language-yaml"><code class="language-yaml">    /contacts:
      get:
        is: [errorResponses]
        description: Get contacts for a specific customer
        responses:
          200:
            body:
              application/json:
                type: Contact[]
                example:
                  -
                    id: "CONT-001"
                    firstName: "Chelsey"
                    lastName: "Graham"
                    email: "chelsey.graham@romaguera.com"
                    phone: "555-0101"
                    title: "VP Sales"
                    accountId: "ACCT-001"
                  -
                    id: "CONT-002"
                    firstName: "Dennis"
                    lastName: "Graham"
                    email: "dennis.graham@romaguera.com"
                    phone: "555-0102"
                    title: "CTO"
                    accountId: "ACCT-001"</code></pre>
          <div class="validation">Validation: In the API Console, Try It on GET /customers/{customerId}/contacts returns your 2 example contacts.</div>
        </div>
      </div>

      <!-- Step 7 -->
      <div class="lab-step">
        <div class="step-number">7</div>
        <div class="step-content">
          <h4>Add Error Responses Trait</h4>
          <p>Define a <code>traits:</code> block (after <code>types:</code>, before <code>/customers:</code>) with an <code>errorResponses</code> trait. Then apply it to all methods with <code>is: [errorResponses]</code> (if you haven't already).</p>
<pre class="language-yaml"><code class="language-yaml">traits:
  errorResponses:
    responses:
      400:
        body:
          application/json:
            example:
              message: "Bad request"
              code: 400
      404:
        body:
          application/json:
            example:
              message: "Resource not found"
              code: 404
      500:
        body:
          application/json:
            example:
              message: "Internal server error"
              code: 500</code></pre>
          <div class="validation">Validation: Every endpoint in the API Console now shows 400, 404, and 500 response options in addition to their success responses.</div>
        </div>
      </div>

      <!-- Step 8 -->
      <div class="lab-step">
        <div class="step-number">8</div>
        <div class="step-content">
          <h4>Publish to Exchange</h4>
          <p>Open the Command Palette (<strong>Cmd+Shift+P</strong> / <strong>Ctrl+Shift+P</strong>) and run <strong>"MuleSoft: Publish API Project to Exchange"</strong>. Authenticate if prompted, select your business group, and fill in:</p>
          <ul>
            <li>Asset version: <strong>1.0.0</strong></li>
            <li>API version: <strong>v1</strong></li>
          </ul>
          <p>When asked "implement the API now?", select <strong>No</strong>. We'll scaffold in Module 4.</p>
          <div class="validation">Validation: Open Anypoint Exchange in your browser. Search for "Customer System API" &mdash; it appears with version 1.0.0.</div>
        </div>
      </div>

      <details class="instructor-note">
        <summary>Instructor Note: Common Student Issues</summary>
        <ul>
          <li><strong>YAML indentation:</strong> RAML is YAML-based. A single extra space breaks everything. If students see errors, check indentation first. ACB shows red underlines for syntax errors.</li>
          <li><strong>Missing <code>mediaType:</code>:</strong> If students get "Payload media type is mandatory" errors, they need to add <code>mediaType: application/json</code> at the root level (it's in the starter header).</li>
          <li><strong><code>schemas:</code> vs <code>types:</code>:</strong> If students copy from old tutorials, they may use the deprecated <code>schemas:</code> keyword. RAML 1.0 uses <code>types:</code>.</li>
          <li><strong>Traits order:</strong> The <code>traits:</code> block must appear before the resources that reference it. If <code>is: [errorResponses]</code> shows an error, the trait isn't defined yet.</li>
          <li><strong>Publish fails:</strong> Check that students are logged into Anypoint Platform. The status bar at the bottom of VS Code should show a green connection icon. If not, run "MuleSoft: Login to Anypoint Platform" from the Command Palette.</li>
        </ul>
      </details>

      <!-- Complete Solution (collapsible) -->
      <details>
        <summary><strong>Complete Solution</strong> (click to expand)</summary>
<pre class="language-yaml"><code class="language-yaml">#%RAML 1.0
title: Customer System API
version: v1
baseUri: http://localhost:8081/api
mediaType: application/json

types:
  Customer:
    properties:
      id: string
      firstName: string
      lastName: string
      email: string
      phone?: string
      company: string
      industry: string
      billingStreet?: string
      billingCity?: string
      billingState?: string
      billingPostalCode?: string

  Contact:
    properties:
      id: string
      firstName: string
      lastName: string
      email: string
      phone?: string
      title?: string
      accountId: string

  ErrorResponse:
    properties:
      message: string
      code: integer

traits:
  errorResponses:
    responses:
      400:
        body:
          application/json:
            type: ErrorResponse
            example:
              message: "Bad request"
              code: 400
      404:
        body:
          application/json:
            type: ErrorResponse
            example:
              message: "Resource not found"
              code: 404
      500:
        body:
          application/json:
            type: ErrorResponse
            example:
              message: "Internal server error"
              code: 500

/customers:
  get:
    is: [errorResponses]
    description: List customers, optionally filtered by industry
    queryParameters:
      industry:
        type: string
        required: false
        description: Filter customers by industry
      limit:
        type: integer
        default: 25
        minimum: 1
        maximum: 100
        description: Maximum number of results to return
      offset:
        type: integer
        default: 0
        description: Number of results to skip for pagination
    responses:
      200:
        body:
          application/json:
            type: Customer[]
            example:
              -
                id: "ACCT-001"
                firstName: "Leanne"
                lastName: "Graham"
                email: "leanne.graham@romaguera.com"
                company: "Romaguera-Crona"
                industry: "Technology"
              -
                id: "ACCT-002"
                firstName: "Ervin"
                lastName: "Howell"
                email: "ervin.howell@deckow.com"
                company: "Deckow-Crist"
                industry: "Technology"
              -
                id: "ACCT-004"
                firstName: "Patricia"
                lastName: "Lebsack"
                email: "patricia.lebsack@robel.com"
                company: "Robel-Corkery"
                industry: "Technology"

  post:
    is: [errorResponses]
    description: Create a new customer
    body:
      application/json:
        type: Customer
        example:
          id: "ACCT-011"
          firstName: "Jane"
          lastName: "Doe"
          email: "jane.doe@newcorp.com"
          company: "NewCorp Industries"
          industry: "Technology"
    responses:
      201:
        body:
          application/json:
            type: Customer
            example:
              id: "ACCT-011"
              firstName: "Jane"
              lastName: "Doe"
              email: "jane.doe@newcorp.com"
              company: "NewCorp Industries"
              industry: "Technology"

  /{customerId}:
    get:
      is: [errorResponses]
      description: Get a single customer by ID
      responses:
        200:
          body:
            application/json:
              type: Customer
              example:
                id: "ACCT-001"
                firstName: "Leanne"
                lastName: "Graham"
                email: "leanne.graham@romaguera.com"
                phone: "555-0001"
                company: "Romaguera-Crona"
                industry: "Technology"
                billingStreet: "123 Innovation Drive"
                billingCity: "San Francisco"
                billingState: "CA"
                billingPostalCode: "94105"

    put:
      is: [errorResponses]
      description: Update an existing customer
      body:
        application/json:
          type: Customer
          example:
            id: "ACCT-001"
            firstName: "Leanne"
            lastName: "Graham"
            email: "leanne.graham@romaguera.com"
            phone: "555-0001"
            company: "Romaguera-Crona"
            industry: "Technology"
            billingStreet: "456 Updated Blvd"
            billingCity: "San Francisco"
            billingState: "CA"
            billingPostalCode: "94105"
      responses:
        200:
          body:
            application/json:
              type: Customer
              example:
                id: "ACCT-001"
                firstName: "Leanne"
                lastName: "Graham"
                email: "leanne.graham@romaguera.com"
                phone: "555-0001"
                company: "Romaguera-Crona"
                industry: "Technology"
                billingStreet: "456 Updated Blvd"
                billingCity: "San Francisco"
                billingState: "CA"
                billingPostalCode: "94105"

    /contacts:
      get:
        is: [errorResponses]
        description: Get contacts for a specific customer
        responses:
          200:
            body:
              application/json:
                type: Contact[]
                example:
                  -
                    id: "CONT-001"
                    firstName: "Chelsey"
                    lastName: "Graham"
                    email: "chelsey.graham@romaguera.com"
                    phone: "555-0101"
                    title: "VP Sales"
                    accountId: "ACCT-001"
                  -
                    id: "CONT-002"
                    firstName: "Dennis"
                    lastName: "Graham"
                    email: "dennis.graham@romaguera.com"
                    phone: "555-0102"
                    title: "CTO"
                    accountId: "ACCT-001"</code></pre>
      </details>

    </section>

    <!-- SECTION 5: LAB 2 (Bonus) -->
    <section id="lab2" class="lab-section-advanced">
      <h2>Lab 2 (Bonus): Modularize Your API Spec</h2>

      <p>Real-world RAML specs aren't 200-line monoliths. In this bonus lab, you'll split your spec into reusable fragments &mdash; the same pattern you'll use with DataWeave modules in Module 5. This is how professional API teams organize large specs: each data type, trait, and example lives in its own file.</p>

      <div class="callout callout-info">
        <div class="callout-title">Starting Point</div>
        <p>Start with your completed monolithic spec from Lab 1 (or use <code>lab-modular/starter/customer-system-api.raml</code> which is a copy of the solution).</p>
      </div>

      <!-- Step 1 -->
      <div class="lab-step">
        <div class="step-number">1</div>
        <div class="step-content">
          <h4>Create the Directory Structure</h4>
          <p>In your project folder, create these directories alongside your main RAML file:</p>
<pre class="language-bash"><code class="language-bash">customer-system-api/
  customer-system-api.raml    # Main file (you'll update this)
  data-types/
    customer.raml             # Customer type fragment
    contact.raml              # Contact type fragment
  traits/
    error-responses.raml      # Error trait fragment
  examples/
    customer-example.json     # Single customer
    customer-list-example.json  # Array of 3 customers
    contact-list-example.json   # Array of 2 contacts
    error-example.json          # Error response</code></pre>
          <div class="validation">Validation: Directory structure exists with empty files ready to fill.</div>
        </div>
      </div>

      <!-- Step 2 -->
      <div class="lab-step">
        <div class="step-number">2</div>
        <div class="step-content">
          <h4>Extract Customer Data Type</h4>
          <p>Move the Customer type into <code>data-types/customer.raml</code> as a DataType fragment. The fragment header replaces the <code>types:</code> wrapper:</p>
<pre class="language-yaml"><code class="language-yaml">#%RAML 1.0 DataType
properties:
  id: string
  firstName: string
  lastName: string
  email: string
  phone?: string
  company: string
  industry: string
  billingStreet?: string
  billingCity?: string
  billingState?: string
  billingPostalCode?: string</code></pre>
          <div class="validation">Validation: File starts with <code>#%RAML 1.0 DataType</code> and contains only the properties (no <code>types:</code> or <code>Customer:</code> wrapper).</div>
        </div>
      </div>

      <!-- Step 3 -->
      <div class="lab-step">
        <div class="step-number">3</div>
        <div class="step-content">
          <h4>Extract Contact Data Type</h4>
          <p>Same pattern for <code>data-types/contact.raml</code>:</p>
<pre class="language-yaml"><code class="language-yaml">#%RAML 1.0 DataType
properties:
  id: string
  firstName: string
  lastName: string
  email: string
  phone?: string
  title?: string
  accountId: string</code></pre>
          <div class="validation">Validation: Both fragment files are valid DataType fragments.</div>
        </div>
      </div>

      <!-- Step 4 -->
      <div class="lab-step">
        <div class="step-number">4</div>
        <div class="step-content">
          <h4>Extract Error Responses Trait</h4>
          <p>Move the error trait into <code>traits/error-responses.raml</code> as a Trait fragment:</p>
<pre class="language-yaml"><code class="language-yaml">#%RAML 1.0 Trait
responses:
  400:
    body:
      application/json:
        example:
          message: "Bad request"
          code: 400
  404:
    body:
      application/json:
        example:
          message: "Resource not found"
          code: 404
  500:
    body:
      application/json:
        example:
          message: "Internal server error"
          code: 500</code></pre>
          <div class="validation">Validation: File starts with <code>#%RAML 1.0 Trait</code> and contains only the responses (no <code>traits:</code> wrapper).</div>
        </div>
      </div>

      <!-- Step 5 -->
      <div class="lab-step">
        <div class="step-number">5</div>
        <div class="step-content">
          <h4>Move Examples to JSON Files</h4>
          <p>Extract the example payloads into standalone JSON files in the <code>examples/</code> directory. For example, <code>examples/customer-list-example.json</code>:</p>
<pre class="language-json"><code class="language-json">[
  {
    "id": "ACCT-001",
    "firstName": "Leanne",
    "lastName": "Graham",
    "email": "leanne.graham@romaguera.com",
    "company": "Romaguera-Crona",
    "industry": "Technology"
  },
  {
    "id": "ACCT-002",
    "firstName": "Ervin",
    "lastName": "Howell",
    "email": "ervin.howell@deckow.com",
    "company": "Deckow-Crist",
    "industry": "Technology"
  },
  {
    "id": "ACCT-004",
    "firstName": "Patricia",
    "lastName": "Lebsack",
    "email": "patricia.lebsack@robel.com",
    "company": "Robel-Corkery",
    "industry": "Technology"
  }
]</code></pre>
          <p>Do the same for <code>customer-example.json</code> (single ACCT-001 with billing), <code>contact-list-example.json</code> (2 contacts), and <code>error-example.json</code>.</p>
          <div class="validation">Validation: All JSON files are valid (no trailing commas, proper brackets).</div>
        </div>
      </div>

      <!-- Step 6 -->
      <div class="lab-step">
        <div class="step-number">6</div>
        <div class="step-content">
          <h4>Update Main RAML with !include References</h4>
          <p>Replace the inline definitions in your main RAML with <code>!include</code> references:</p>
<pre class="language-yaml"><code class="language-yaml">types:
  Customer: !include data-types/customer.raml
  Contact: !include data-types/contact.raml
  ErrorResponse:
    properties:
      message: string
      code: integer

traits:
  errorResponses: !include traits/error-responses.raml</code></pre>
          <p>For examples in your responses, replace inline examples with:</p>
<pre class="language-yaml"><code class="language-yaml">            example: !include examples/customer-list-example.json</code></pre>
          <div class="validation">Validation: No red errors in ACB. The spec resolves all includes correctly.</div>
        </div>
      </div>

      <!-- Step 7 -->
      <div class="lab-step">
        <div class="step-number">7</div>
        <div class="step-content">
          <h4>Verify Everything Still Works</h4>
          <p>Open the API Console and test every endpoint with Try It. The mocking service should return the same responses as before &mdash; the spec is functionally identical, just better organized.</p>
          <div class="validation">Validation: All endpoints still work in API Console Try It. GET /customers returns 3 customers. GET /customers/{customerId}/contacts returns 2 contacts. Every endpoint shows 400, 404, 500 error responses.</div>
        </div>
      </div>

      <details class="instructor-note">
        <summary>Instructor Note: When to Modularize</summary>
        <p>Students may ask "When is it worth modularizing?" Answer: when your spec exceeds ~100 lines, when multiple APIs share the same data types, or when a team has multiple people editing the spec. For this course, the monolithic version is perfectly fine. Modularization becomes essential in enterprise environments where you might have 20+ APIs sharing Customer, Contact, and Error types.</p>
      </details>

    </section>

    <!-- Closing -->
    <div class="closing-banner">
      <h3>API Contract Complete</h3>
      <p>You've designed, tested, and published your Customer System API. In Module 4, you'll bring it to life &mdash; scaffolding a Mule project from this spec and wiring up real connectors to Salesforce, REST APIs, databases, and SOAP services.</p>
    </div>

    <!-- Footer Navigation -->
    <footer class="module-footer">
      <a href="../02-anypoint-platform-tour/module-02.html">&larr; Module 2: Your Anypoint Platform</a>
      <a href="../04-integrations-rest-soap-db/module-04.html">Next: Module 4 &mdash; Building the Customer Enrichment Engine &rarr;</a>
    </footer>

  </main>

</body>
</html>
